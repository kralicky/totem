// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - ragu               v1.0.0
// source: github.com/kralicky/totem/test/test.proto

package test

import (
	context "context"
	totem "github.com/kralicky/totem"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TestClient is the client API for Test service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TestClient interface {
	TestStream(ctx context.Context, opts ...grpc.CallOption) (Test_TestStreamClient, error)
}

type testClient struct {
	cc grpc.ClientConnInterface
}

func NewTestClient(cc grpc.ClientConnInterface) TestClient {
	return &testClient{cc}
}

func (c *testClient) TestStream(ctx context.Context, opts ...grpc.CallOption) (Test_TestStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Test_ServiceDesc.Streams[0], "/test.Test/TestStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &testTestStreamClient{stream}
	return x, nil
}

type Test_TestStreamClient interface {
	Send(*totem.RPC) error
	Recv() (*totem.RPC, error)
	grpc.ClientStream
}

type testTestStreamClient struct {
	grpc.ClientStream
}

func (x *testTestStreamClient) Send(m *totem.RPC) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testTestStreamClient) Recv() (*totem.RPC, error) {
	m := new(totem.RPC)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TestServer is the server API for Test service.
// All implementations must embed UnimplementedTestServer
// for forward compatibility
type TestServer interface {
	TestStream(Test_TestStreamServer) error
	mustEmbedUnimplementedTestServer()
}

// UnimplementedTestServer must be embedded to have forward compatible implementations.
type UnimplementedTestServer struct {
}

func (UnimplementedTestServer) TestStream(Test_TestStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method TestStream not implemented")
}
func (UnimplementedTestServer) mustEmbedUnimplementedTestServer() {}

// UnsafeTestServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TestServer will
// result in compilation errors.
type UnsafeTestServer interface {
	mustEmbedUnimplementedTestServer()
}

func RegisterTestServer(s grpc.ServiceRegistrar, srv TestServer) {
	s.RegisterService(&Test_ServiceDesc, srv)
}

func _Test_TestStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TestServer).TestStream(&testTestStreamServer{stream})
}

type Test_TestStreamServer interface {
	Send(*totem.RPC) error
	Recv() (*totem.RPC, error)
	grpc.ServerStream
}

type testTestStreamServer struct {
	grpc.ServerStream
}

func (x *testTestStreamServer) Send(m *totem.RPC) error {
	return x.ServerStream.SendMsg(m)
}

func (x *testTestStreamServer) Recv() (*totem.RPC, error) {
	m := new(totem.RPC)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Test_ServiceDesc is the grpc.ServiceDesc for Test service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Test_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Test",
	HandlerType: (*TestServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TestStream",
			Handler:       _Test_TestStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// IncrementClient is the client API for Increment service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IncrementClient interface {
	Inc(ctx context.Context, in *Number, opts ...grpc.CallOption) (*Number, error)
}

type incrementClient struct {
	cc grpc.ClientConnInterface
}

func NewIncrementClient(cc grpc.ClientConnInterface) IncrementClient {
	return &incrementClient{cc}
}

func (c *incrementClient) Inc(ctx context.Context, in *Number, opts ...grpc.CallOption) (*Number, error) {
	out := new(Number)
	err := c.cc.Invoke(ctx, "/test.Increment/Inc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IncrementServer is the server API for Increment service.
// All implementations must embed UnimplementedIncrementServer
// for forward compatibility
type IncrementServer interface {
	Inc(context.Context, *Number) (*Number, error)
	mustEmbedUnimplementedIncrementServer()
}

// UnimplementedIncrementServer must be embedded to have forward compatible implementations.
type UnimplementedIncrementServer struct {
}

func (UnimplementedIncrementServer) Inc(context.Context, *Number) (*Number, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Inc not implemented")
}
func (UnimplementedIncrementServer) mustEmbedUnimplementedIncrementServer() {}

// UnsafeIncrementServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IncrementServer will
// result in compilation errors.
type UnsafeIncrementServer interface {
	mustEmbedUnimplementedIncrementServer()
}

func RegisterIncrementServer(s grpc.ServiceRegistrar, srv IncrementServer) {
	s.RegisterService(&Increment_ServiceDesc, srv)
}

func _Increment_Inc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Number)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IncrementServer).Inc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Increment/Inc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IncrementServer).Inc(ctx, req.(*Number))
	}
	return interceptor(ctx, in, info, handler)
}

// Increment_ServiceDesc is the grpc.ServiceDesc for Increment service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Increment_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Increment",
	HandlerType: (*IncrementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Inc",
			Handler:    _Increment_Inc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// DecrementClient is the client API for Decrement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DecrementClient interface {
	Dec(ctx context.Context, in *Number, opts ...grpc.CallOption) (*Number, error)
}

type decrementClient struct {
	cc grpc.ClientConnInterface
}

func NewDecrementClient(cc grpc.ClientConnInterface) DecrementClient {
	return &decrementClient{cc}
}

func (c *decrementClient) Dec(ctx context.Context, in *Number, opts ...grpc.CallOption) (*Number, error) {
	out := new(Number)
	err := c.cc.Invoke(ctx, "/test.Decrement/Dec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DecrementServer is the server API for Decrement service.
// All implementations must embed UnimplementedDecrementServer
// for forward compatibility
type DecrementServer interface {
	Dec(context.Context, *Number) (*Number, error)
	mustEmbedUnimplementedDecrementServer()
}

// UnimplementedDecrementServer must be embedded to have forward compatible implementations.
type UnimplementedDecrementServer struct {
}

func (UnimplementedDecrementServer) Dec(context.Context, *Number) (*Number, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dec not implemented")
}
func (UnimplementedDecrementServer) mustEmbedUnimplementedDecrementServer() {}

// UnsafeDecrementServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DecrementServer will
// result in compilation errors.
type UnsafeDecrementServer interface {
	mustEmbedUnimplementedDecrementServer()
}

func RegisterDecrementServer(s grpc.ServiceRegistrar, srv DecrementServer) {
	s.RegisterService(&Decrement_ServiceDesc, srv)
}

func _Decrement_Dec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Number)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecrementServer).Dec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Decrement/Dec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecrementServer).Dec(ctx, req.(*Number))
	}
	return interceptor(ctx, in, info, handler)
}

// Decrement_ServiceDesc is the grpc.ServiceDesc for Decrement service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Decrement_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Decrement",
	HandlerType: (*DecrementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dec",
			Handler:    _Decrement_Dec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// HashClient is the client API for Hash service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HashClient interface {
	Hash(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error)
}

type hashClient struct {
	cc grpc.ClientConnInterface
}

func NewHashClient(cc grpc.ClientConnInterface) HashClient {
	return &hashClient{cc}
}

func (c *hashClient) Hash(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error) {
	out := new(String)
	err := c.cc.Invoke(ctx, "/test.Hash/Hash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HashServer is the server API for Hash service.
// All implementations must embed UnimplementedHashServer
// for forward compatibility
type HashServer interface {
	Hash(context.Context, *String) (*String, error)
	mustEmbedUnimplementedHashServer()
}

// UnimplementedHashServer must be embedded to have forward compatible implementations.
type UnimplementedHashServer struct {
}

func (UnimplementedHashServer) Hash(context.Context, *String) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hash not implemented")
}
func (UnimplementedHashServer) mustEmbedUnimplementedHashServer() {}

// UnsafeHashServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HashServer will
// result in compilation errors.
type UnsafeHashServer interface {
	mustEmbedUnimplementedHashServer()
}

func RegisterHashServer(s grpc.ServiceRegistrar, srv HashServer) {
	s.RegisterService(&Hash_ServiceDesc, srv)
}

func _Hash_Hash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashServer).Hash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Hash/Hash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashServer).Hash(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

// Hash_ServiceDesc is the grpc.ServiceDesc for Hash service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hash_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Hash",
	HandlerType: (*HashServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Hash",
			Handler:    _Hash_Hash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// NotifyClient is the client API for Notify service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotifyClient interface {
	Notify(ctx context.Context, in *String, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type notifyClient struct {
	cc grpc.ClientConnInterface
}

func NewNotifyClient(cc grpc.ClientConnInterface) NotifyClient {
	return &notifyClient{cc}
}

func (c *notifyClient) Notify(ctx context.Context, in *String, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.Notify/Notify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotifyServer is the server API for Notify service.
// All implementations must embed UnimplementedNotifyServer
// for forward compatibility
type NotifyServer interface {
	Notify(context.Context, *String) (*emptypb.Empty, error)
	mustEmbedUnimplementedNotifyServer()
}

// UnimplementedNotifyServer must be embedded to have forward compatible implementations.
type UnimplementedNotifyServer struct {
}

func (UnimplementedNotifyServer) Notify(context.Context, *String) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedNotifyServer) mustEmbedUnimplementedNotifyServer() {}

// UnsafeNotifyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotifyServer will
// result in compilation errors.
type UnsafeNotifyServer interface {
	mustEmbedUnimplementedNotifyServer()
}

func RegisterNotifyServer(s grpc.ServiceRegistrar, srv NotifyServer) {
	s.RegisterService(&Notify_ServiceDesc, srv)
}

func _Notify_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Notify/Notify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).Notify(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

// Notify_ServiceDesc is the grpc.ServiceDesc for Notify service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notify_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Notify",
	HandlerType: (*NotifyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _Notify_Notify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// MultiplyClient is the client API for Multiply service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MultiplyClient interface {
	Mul(ctx context.Context, in *Operands, opts ...grpc.CallOption) (*Number, error)
}

type multiplyClient struct {
	cc grpc.ClientConnInterface
}

func NewMultiplyClient(cc grpc.ClientConnInterface) MultiplyClient {
	return &multiplyClient{cc}
}

func (c *multiplyClient) Mul(ctx context.Context, in *Operands, opts ...grpc.CallOption) (*Number, error) {
	out := new(Number)
	err := c.cc.Invoke(ctx, "/test.Multiply/Mul", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MultiplyServer is the server API for Multiply service.
// All implementations must embed UnimplementedMultiplyServer
// for forward compatibility
type MultiplyServer interface {
	Mul(context.Context, *Operands) (*Number, error)
	mustEmbedUnimplementedMultiplyServer()
}

// UnimplementedMultiplyServer must be embedded to have forward compatible implementations.
type UnimplementedMultiplyServer struct {
}

func (UnimplementedMultiplyServer) Mul(context.Context, *Operands) (*Number, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mul not implemented")
}
func (UnimplementedMultiplyServer) mustEmbedUnimplementedMultiplyServer() {}

// UnsafeMultiplyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MultiplyServer will
// result in compilation errors.
type UnsafeMultiplyServer interface {
	mustEmbedUnimplementedMultiplyServer()
}

func RegisterMultiplyServer(s grpc.ServiceRegistrar, srv MultiplyServer) {
	s.RegisterService(&Multiply_ServiceDesc, srv)
}

func _Multiply_Mul_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Operands)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplyServer).Mul(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Multiply/Mul",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplyServer).Mul(ctx, req.(*Operands))
	}
	return interceptor(ctx, in, info, handler)
}

// Multiply_ServiceDesc is the grpc.ServiceDesc for Multiply service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Multiply_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Multiply",
	HandlerType: (*MultiplyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mul",
			Handler:    _Multiply_Mul_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// ErrorClient is the client API for Error service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ErrorClient interface {
	Error(ctx context.Context, in *ErrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type errorClient struct {
	cc grpc.ClientConnInterface
}

func NewErrorClient(cc grpc.ClientConnInterface) ErrorClient {
	return &errorClient{cc}
}

func (c *errorClient) Error(ctx context.Context, in *ErrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.Error/Error", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ErrorServer is the server API for Error service.
// All implementations must embed UnimplementedErrorServer
// for forward compatibility
type ErrorServer interface {
	Error(context.Context, *ErrorRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedErrorServer()
}

// UnimplementedErrorServer must be embedded to have forward compatible implementations.
type UnimplementedErrorServer struct {
}

func (UnimplementedErrorServer) Error(context.Context, *ErrorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Error not implemented")
}
func (UnimplementedErrorServer) mustEmbedUnimplementedErrorServer() {}

// UnsafeErrorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ErrorServer will
// result in compilation errors.
type UnsafeErrorServer interface {
	mustEmbedUnimplementedErrorServer()
}

func RegisterErrorServer(s grpc.ServiceRegistrar, srv ErrorServer) {
	s.RegisterService(&Error_ServiceDesc, srv)
}

func _Error_Error_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorServer).Error(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Error/Error",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorServer).Error(ctx, req.(*ErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Error_ServiceDesc is the grpc.ServiceDesc for Error service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Error_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Error",
	HandlerType: (*ErrorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Error",
			Handler:    _Error_Error_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}

// EchoClient is the client API for Echo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EchoClient interface {
	Echo(ctx context.Context, in *Bytes, opts ...grpc.CallOption) (*Bytes, error)
}

type echoClient struct {
	cc grpc.ClientConnInterface
}

func NewEchoClient(cc grpc.ClientConnInterface) EchoClient {
	return &echoClient{cc}
}

func (c *echoClient) Echo(ctx context.Context, in *Bytes, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, "/test.Echo/Echo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EchoServer is the server API for Echo service.
// All implementations must embed UnimplementedEchoServer
// for forward compatibility
type EchoServer interface {
	Echo(context.Context, *Bytes) (*Bytes, error)
	mustEmbedUnimplementedEchoServer()
}

// UnimplementedEchoServer must be embedded to have forward compatible implementations.
type UnimplementedEchoServer struct {
}

func (UnimplementedEchoServer) Echo(context.Context, *Bytes) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}
func (UnimplementedEchoServer) mustEmbedUnimplementedEchoServer() {}

// UnsafeEchoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EchoServer will
// result in compilation errors.
type UnsafeEchoServer interface {
	mustEmbedUnimplementedEchoServer()
}

func RegisterEchoServer(s grpc.ServiceRegistrar, srv EchoServer) {
	s.RegisterService(&Echo_ServiceDesc, srv)
}

func _Echo_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bytes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Echo/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServer).Echo(ctx, req.(*Bytes))
	}
	return interceptor(ctx, in, info, handler)
}

// Echo_ServiceDesc is the grpc.ServiceDesc for Echo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Echo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.Echo",
	HandlerType: (*EchoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _Echo_Echo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kralicky/totem/test/test.proto",
}
